import React, { useRef, useState, useLayoutEffect, useEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';
import useMutationObserver from '@rooks/use-mutation-observer';
import ResizeObserver from 'resize-observer-polyfill';

var Portal = function Portal(_ref) {
  var children = _ref.children,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'reactour-portal' : _ref$type;
  var mountNode = useRef(null);
  var portalNode = useRef(null);

  var _useState = useState({}),
      forceUpdate = _useState[1];

  useLayoutEffect(function () {
    if (!mountNode.current) return;
    var ownerDocument = mountNode.current.ownerDocument;
    portalNode.current = ownerDocument == null ? void 0 : ownerDocument.createElement(type);
    ownerDocument.body.appendChild(portalNode.current);
    forceUpdate({});
    return function () {
      if (portalNode.current && portalNode.current.ownerDocument) {
        portalNode.current.ownerDocument.body.removeChild(portalNode.current);
      }
    };
  }, [type]);
  return portalNode.current ? createPortal(children, portalNode.current) : React.createElement("span", {
    ref: mountNode
  });
};

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Observables = function Observables(_ref) {
  var mutationObservables = _ref.mutationObservables,
      resizeObservables = _ref.resizeObservables,
      refresh = _ref.refresh;

  var _useState = useState(0),
      mutationsCounter = _useState[0],
      setMutationsCounter = _useState[1];

  var ref = useRef(document.documentElement || document.body);

  function refreshHighlightedRegionIfObservable(nodes) {
    var posibleNodes = Array.from(nodes);

    var _loop = function _loop() {
      var node = _posibleNodes[_i];

      if (mutationObservables) {
        if (!node.attributes) {
          return "continue";
        }

        var found = mutationObservables.find(function (observable) {
          return node.matches(observable);
        });

        if (found) {
          refresh(true);
        }
      }
    };

    for (var _i = 0, _posibleNodes = posibleNodes; _i < _posibleNodes.length; _i++) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  }

  function incrementMutationsCounterIfObservable(nodes) {
    var posibleNodes = Array.from(nodes);

    var _loop2 = function _loop2() {
      var node = _posibleNodes2[_i2];

      if (resizeObservables) {
        if (!node.attributes) {
          return "continue";
        }

        var found = resizeObservables.find(function (observable) {
          return node.matches(observable);
        });
        if (found) setMutationsCounter(mutationsCounter + 1);
      }
    };

    for (var _i2 = 0, _posibleNodes2 = posibleNodes; _i2 < _posibleNodes2.length; _i2++) {
      var _ret2 = _loop2();

      if (_ret2 === "continue") continue;
    }
  }

  useMutationObserver(ref, function (mutationList) {
    for (var _iterator = _createForOfIteratorHelperLoose(mutationList), _step; !(_step = _iterator()).done;) {
      var mutation = _step.value;

      if (mutation.addedNodes.length !== 0) {
        refreshHighlightedRegionIfObservable(mutation.addedNodes);
        incrementMutationsCounterIfObservable(mutation.addedNodes);
      }

      if (mutation.removedNodes.length !== 0) {
        refreshHighlightedRegionIfObservable(mutation.removedNodes);
        incrementMutationsCounterIfObservable(mutation.removedNodes);
      }
    }
  }, {
    childList: true,
    subtree: true
  });
  useEffect(function () {
    if (!resizeObservables) {
      return;
    }

    var resizeObserver = new ResizeObserver(function () {
      refresh();
    });

    for (var _iterator2 = _createForOfIteratorHelperLoose(resizeObservables), _step2; !(_step2 = _iterator2()).done;) {
      var observable = _step2.value;
      var element = document.querySelector(observable);

      if (element) {
        resizeObserver.observe(element);
      }
    }

    return function () {
      resizeObserver.disconnect();
    };
  }, [resizeObservables, mutationsCounter]);
  return null;
};

function getRect(element) {
  var rect = {
    bottom: 0,
    height: 0,
    left: 0,
    right: 0,
    top: 0,
    width: 0
  };

  if (element) {
    var domRect = element.getBoundingClientRect();
    rect = {
      bottom: domRect.bottom,
      height: domRect.height,
      left: domRect.left,
      right: domRect.right,
      top: domRect.top,
      width: domRect.width
    };
  }

  return rect;
}
function useRect(ref, refresher) {
  var _useState = useState(initialState),
      dimensions = _useState[0],
      setdDimensions = _useState[1];

  var handleResize = useCallback(function () {
    if (!(ref != null && ref.current)) return;
    setdDimensions(getRect(ref == null ? void 0 : ref.current));
  }, [ref == null ? void 0 : ref.current]);
  useEffect(function () {
    handleResize();
    window.addEventListener('resize', handleResize);
    return function () {
      return window.removeEventListener('resize', handleResize);
    };
  }, [ref == null ? void 0 : ref.current, refresher]);
  return dimensions;
}
function useElemRect(elem, refresher) {
  var _useState2 = useState(initialState),
      dimensions = _useState2[0],
      setdDimensions = _useState2[1];

  var handleResize = useCallback(function () {
    if (!elem) return;
    setdDimensions(getRect(elem));
  }, [elem]);
  useEffect(function () {
    handleResize();
    window.addEventListener('resize', handleResize);
    return function () {
      return window.removeEventListener('resize', handleResize);
    };
  }, [elem, refresher]);
  return dimensions;
}
var initialState = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0
};

// https://stackoverflow.com/questions/46795955/how-to-know-scroll-to-element-is-done-in-javascript
function smoothScroll(elem, options) {
  return new Promise(function (resolve) {
    if (!(elem instanceof Element)) {
      throw new TypeError('Argument 1 must be an Element');
    }

    var same = 0;
    var lastPos = null;
    var scrollOptions = Object.assign({
      behavior: 'smooth'
    }, options);
    elem.scrollIntoView(scrollOptions);
    requestAnimationFrame(check);

    function check() {
      var newPos = elem == null ? void 0 : elem.getBoundingClientRect().top;

      if (newPos === lastPos) {
        if (same++ > 2) {
          return resolve(null);
        }
      } else {
        same = 0;
        lastPos = newPos;
      }

      requestAnimationFrame(check);
    }
  });
}

function safe(sum) {
  return sum < 0 ? 0 : sum;
}

function getInViewThreshold(threshold) {
  if (typeof threshold === 'object' && threshold !== null) {
    return {
      thresholdX: threshold.x || 0,
      thresholdY: threshold.y || 0
    };
  }

  return {
    thresholdX: threshold || 0,
    thresholdY: threshold || 0
  };
}

function getWindow() {
  var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  return {
    w: w,
    h: h
  };
}
function inView(_ref) {
  var top = _ref.top,
      right = _ref.right,
      bottom = _ref.bottom,
      left = _ref.left,
      threshold = _ref.threshold;

  var _getWindow = getWindow(),
      windowWidth = _getWindow.w,
      windowHeight = _getWindow.h;

  var _getInViewThreshold = getInViewThreshold(threshold),
      thresholdX = _getInViewThreshold.thresholdX,
      thresholdY = _getInViewThreshold.thresholdY;

  return top < 0 && bottom - top > windowHeight ? true : top >= 0 + thresholdY && left >= 0 + thresholdX && bottom <= windowHeight - thresholdY && right <= windowWidth - thresholdX;
}
var isHoriz = function isHoriz(pos) {
  return /(left|right)/.test(pos);
};
var isOutsideX = function isOutsideX(val, windowWidth) {
  return val > windowWidth;
};
var isOutsideY = function isOutsideY(val, windowHeight) {
  return val > windowHeight;
};
function bestPositionOf(positions) {
  return Object.keys(positions).map(function (p) {
    return {
      position: p,
      value: positions[p]
    };
  }).sort(function (a, b) {
    return b.value - a.value;
  }).map(function (p) {
    return p.position;
  });
}
var defaultPadding = 10;
function getPadding(padding) {
  if (padding === void 0) {
    padding = defaultPadding;
  }

  if (Array.isArray(padding)) {
    return padding[0] ? [padding[0], padding[1] ? padding[1] : padding[0]] : [defaultPadding, defaultPadding];
  }

  return [padding, padding];
}

export { Observables, Portal, bestPositionOf, getPadding, getRect, getWindow, inView, isHoriz, isOutsideX, isOutsideY, safe, smoothScroll, useElemRect, useRect };
//# sourceMappingURL=utils.esm.js.map
