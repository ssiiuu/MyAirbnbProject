import { jsx } from '@emotion/react';
import { useRef } from 'react';
import { getWindow, useRect, getPadding, isOutsideX, isOutsideY, isHoriz, bestPositionOf } from '@reactour/utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var defaultStyles = {
  popover: function popover() {
    return {
      position: 'fixed',
      maxWidth: 353,
      // minWidth: 150,
      backgroundColor: '#fff',
      padding: '24px 30px',
      boxShadow: '0 0.5em 3em rgba(0, 0, 0, 0.3)',
      color: 'inherit',
      zIndex: 100000,
      transition: 'transform 0.3s',
      top: 0,
      left: 0
    };
  }
};
function stylesMatcher(styles) {
  return function (key, state) {
    var base = defaultStyles[key](state);
    var custom = styles[key];
    return custom ? custom(base, state) : base;
  };
}

var Popover = function Popover(_ref) {
  var children = _ref.children,
      _ref$position = _ref.position,
      providedPosition = _ref$position === void 0 ? 'bottom' : _ref$position,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? 10 : _ref$padding,
      _ref$styles = _ref.styles,
      styles = _ref$styles === void 0 ? {} : _ref$styles,
      sizes = _ref.sizes,
      refresher = _ref.refresher,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "position", "padding", "styles", "sizes", "refresher"]);

  var helperRef = useRef(null);
  var positionRef = useRef('');
  var verticalAlignRef = useRef('');
  var horizontalAlignRef = useRef('');

  var _getWindow = getWindow(),
      windowWidth = _getWindow.w,
      windowHeight = _getWindow.h;

  var getStyles = stylesMatcher(styles);

  var _useRect = useRect(helperRef, refresher),
      helperWidth = _useRect.width,
      helperHeight = _useRect.height;

  var targetLeft = sizes == null ? void 0 : sizes.left;
  var targetTop = sizes == null ? void 0 : sizes.top;
  var targetRight = sizes == null ? void 0 : sizes.right;
  var targetBottom = sizes == null ? void 0 : sizes.bottom;
  var position = providedPosition && typeof providedPosition === 'function' ? providedPosition({
    width: helperWidth,
    height: helperHeight,
    windowWidth: windowWidth,
    windowHeight: windowHeight,
    top: targetTop,
    left: targetLeft,
    right: targetRight,
    bottom: targetBottom
  }) : providedPosition;
  var available = {
    left: targetLeft,
    right: windowWidth - targetRight,
    top: targetTop,
    bottom: windowHeight - targetBottom
  };

  var _getPadding = getPadding(padding),
      px = _getPadding[0],
      py = _getPadding[1];

  var couldPositionAt = function couldPositionAt(position) {
    return available[position] > (isHoriz(position) ? helperWidth + px * 2 : helperHeight + py * 2);
  };

  var autoPosition = function autoPosition(coords) {
    var positionsOrder = bestPositionOf(available);

    for (var j = 0; j < positionsOrder.length; j++) {
      if (couldPositionAt(positionsOrder[j])) {
        positionRef.current = positionsOrder[j];
        return coords[positionsOrder[j]];
      }
    }

    positionRef.current = 'center';
    return coords.center;
  };

  var pos = function pos(helperPosition) {
    if (Array.isArray(helperPosition)) {
      var isOutX = isOutsideX(helperPosition[0], windowWidth);
      var isOutY = isOutsideY(helperPosition[1], windowHeight); // if (isOutX) warn('x', helperPosition[0])
      // if (isOutY) warn('y', helperPosition[1])

      positionRef.current = 'custom';
      return [isOutX ? windowWidth / 2 - helperWidth / 2 : helperPosition[0], isOutY ? windowHeight / 2 - helperHeight / 2 : helperPosition[1]];
    }

    var hX = isOutsideX(targetLeft + helperWidth, windowWidth) ? targetRight - helperWidth + px : targetLeft - px;
    var x = hX > px ? hX : px;
    var hY = isOutsideY(targetTop + helperHeight, windowHeight) ? targetBottom - helperHeight + py : targetTop - py;
    var y = hY > py ? hY : py;

    if (isOutsideY(targetTop + helperHeight, windowHeight)) {
      verticalAlignRef.current = 'bottom';
    } else {
      verticalAlignRef.current = 'top';
    }

    if (isOutsideX(targetLeft + helperWidth, windowWidth)) {
      horizontalAlignRef.current = 'left';
    } else {
      horizontalAlignRef.current = 'right';
    }

    var coords = {
      top: [x, targetTop - helperHeight - py * 2],
      right: [targetRight + px * 2, y],
      bottom: [x, targetBottom + py * 2],
      left: [targetLeft - helperWidth - px * 2, y],
      center: [windowWidth / 2 - helperWidth / 2, windowHeight / 2 - helperHeight / 2]
    };

    if (helperPosition === 'center' || couldPositionAt(helperPosition)) {
      positionRef.current = helperPosition;
      return coords[helperPosition];
    }

    return autoPosition(coords);
  };

  var p = pos(position);
  return jsx("div", Object.assign({
    css: _extends({}, getStyles('popover', {
      position: positionRef.current,
      verticalAlign: verticalAlignRef.current,
      horizontalAlign: horizontalAlignRef.current
    }), {
      transform: "translate(" + Math.round(p[0]) + "px, " + Math.round(p[1]) + "px)"
    }),
    ref: helperRef
  }, props), children);
};
//   console.warn(`${axis}:${num} is outside window, falling back to center`)
// }

export default Popover;
export { Popover };
//# sourceMappingURL=popover.esm.js.map
